# The Zen of Vibe Coding

> *A modern interpretation of programming principles for the age of AI-assisted development*

**Vibe Coding** is an emerging software development practice where developers use natural language prompts to guide AI in generating, refining, and debugging code. [Coined by AI researcher Andrej Karpathy](https://x.com/karpathy/status/1886192184808149383) in early 2025, it represents a shift from writing code line-by-line to directing an AI assistant through a conversational process. This approach allows the developer to focus on the overarching goal and application design, while the AI handles the implementation details.

Vibe coding generally manifests in two forms: "pure" vibe coding for rapid ideation or throwaway projects, and "responsible AI-assisted development," where the developer acts as a guide and maintains full ownership by reviewing, testing, and understanding all generated code.

The following principles adapt the timeless wisdom of the Zen of Python for this new paradigm.

## The Core Principles

### Beautiful is better than ugly, but runnable is better than beautiful.
> While aesthetically pleasing code is valuable, the primary goal is a functioning application. An elegantly structured function is useless if it doesn't run, whereas a working—if imperfect—program provides immediate value and a foundation for improvement.

### Explicit is better than implicit, but verified is better than explicit.
> Clearly stated code and prompts help both humans and AI understand intent. However, explicit instructions are not enough; the generated code must be verified through execution and testing to ensure it behaves as expected, catching errors that explicit instructions might have missed.

### Simple is better than complex, but correct is better than simple.
> Simplicity should be a key aim, as it often leads to more maintainable and understandable code. However, correctness is the non-negotiable foundation. A simple but incorrect solution is worse than a more complex one that works properly.

### Complex is better than complicated, but proven is better than complex.
> Some problems are inherently complex and require sophisticated solutions. A "complex" solution can be well-structured and logical, whereas a "complicated" one is unnecessarily convoluted. When complexity is necessary, it should be backed by proofs or rigorous testing to ensure its reliability.

## The Guiding Tenets

### 1. Duplication is good. Dependency is disaster.
> A small amount of duplicated code can be preferable to introducing a complex, external dependency. Over-reliance on dependencies can lead to security vulnerabilities, breaking changes, and bloated projects, whereas controlled duplication offers simplicity and independence.

### 2. All unverified code is pseudocode.
> Code generated by an AI, or written by a human, is merely a hypothesis until it is executed and validated. Never assume AI-generated code is correct; always treat it as a draft that requires verification through testing and review.

### 3. If the documentation feels weird, the code must be wrong.
> Documentation that is difficult to write or feels awkward often points to underlying design flaws in the code itself. If you struggle to explain what the code does, it may be a sign that the implementation is flawed or overly complex.

### 4. Trust the types, but verify the proofs.
> Leveraging static type checking can catch a class of errors early and make code more robust. However, types alone are not sufficient; you should also use tests and other verification methods to "prove" the code's logic and behavior are correct.

### 5. Haskell is the bridge between Coq and Python - use it wisely.
> This tenet highlights a spectrum of programming language rigor. Coq is for formal, machine-checked proofs; Python is for practical, rapid development. Haskell, with its strong static type system and functional purity, offers a middle ground—a way to incorporate more guarantees into code without the full cost of formal verification.

### 6. Prove code with symbolic execution, prove design with Coq.
> Different tools are suited for different levels of verification. Use techniques like symbolic execution to thoroughly test the runtime behavior of your code. For the most critical design specifications and algorithms, consider using a proof assistant like Coq to achieve mathematical certainty.

### 7. Tests are cheap, but manual verification is priceless.
> Automated tests are inexpensive to run and should be used liberally. However, the manual, intellectual process of reviewing code—checking for security flaws, logical errors, and alignment with requirements—provides an invaluable layer of understanding and oversight that automation cannot replace.

### 8. A script becomes a project when AI cannot fix it greedily.
> A "script" is a small, self-contained piece of code that an AI can understand and modify in a single, "greedy" attempt. When changes require an understanding of a larger architecture, multiple interconnected files, or long-term context, you are dealing with a "project" that demands more sophisticated tooling and human oversight.

### 9. The internet is a distraction - code locally, think globally.
> While an internet connection is often needed for AI tools, constant context-switching to browse the web can break the state of deep focus, or "flow," essential for productive coding. Cultivate a local development environment that minimizes distractions and allows for concentrated thought.

### 10. Your AI lives in a terminal, but your terminal should be everywhere.
> The power of AI-assisted development is best accessed through a command-line interface or terminal-based tools, which are often faster and more scriptable. To maximize productivity, ensure your terminal environment and its context are accessible and consistent across all the machines and platforms you use.

### 11. Your AI should never change in one project and always act as a pure function with no side effects and random outputs.
> For a given project, the behavior of your AI assistant should be consistent and deterministic. Its output should depend solely on your input (the prompt and the code context), not on random variation, ensuring reproducible results and a stable development experience.

### 12. Do not trust your AI service provider unless you are the provider itself.
> Be aware that the companies providing AI coding tools may change their models, pricing, or features in ways that could disrupt your workflow or project. For ultimate control and stability, consider self-hosting AI models where feasible.

### 13. A novel idea emerges good project written by AI which can not be losslessly compressed into idea with same length again by any AI without that novel idea.
> A truly novel and valuable software project created with AI will contain insights and structures that are not fully captured by its original short description. The final implementation embodies a form of irreducibly complex knowledge that cannot be perfectly reverse-engineered back into a simple prompt of the same size.

### 14. Do not introduce novel idea in a script, start a new project; Do not let your project do anything trivial, write a script.
> Respect the boundaries of scale. A "script" should be a simple, single-purpose tool. If you find yourself adding complex, novel functionality, it's time to start a proper "project" with a structured architecture. Conversely, avoid over-engineering; trivial tasks should be solved with simple scripts, not within a larger project.

